<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.49">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/favicon.ico"><title>小郑的博客</title><meta name="description" content="记录我生活的点点积极">
    <link rel="modulepreload" href="/assets/app.73a0ea12.js"><link rel="modulepreload" href="/assets/index.html.5969c65f.js"><link rel="modulepreload" href="/assets/index.html.ef4aed04.js"><link rel="prefetch" href="/assets/index.html.38293f4b.js"><link rel="prefetch" href="/assets/MAC上安装brew方式及使用技巧.html.c0781192.js"><link rel="prefetch" href="/assets/Mac下修改hosts 解决访问github慢的问题.html.4a53202f.js"><link rel="prefetch" href="/assets/mac下docker安装kenkins.html.994330a1.js"><link rel="prefetch" href="/assets/视频流.html.1ace05bd.js"><link rel="prefetch" href="/assets/egg中间件.html.8cc25dc6.js"><link rel="prefetch" href="/assets/egg基础.html.99cdf492.js"><link rel="prefetch" href="/assets/egg定时任务.html.b2f8617b.js"><link rel="prefetch" href="/assets/index.html.f5225c6b.js"><link rel="prefetch" href="/assets/生成接口文档egg-swagger-doc.html.de101b0b.js"><link rel="prefetch" href="/assets/Ubuntu下安装AndroidStudio.html.66726843.js"><link rel="prefetch" href="/assets/安卓打包icon及其启动页图片大小.html.89616046.js"><link rel="prefetch" href="/assets/Flutter-原生路由.html.c892e5e4.js"><link rel="prefetch" href="/assets/Flutter-常用库及时使用入门级方法-一些经常用到的的副本.html.be437e49.js"><link rel="prefetch" href="/assets/Flutter创建插件详解并发布到Pub库.html.fcb7093a.js"><link rel="prefetch" href="/assets/flutter_fluro.html.f3a3c3f7.js"><link rel="prefetch" href="/assets/flutter_mqtt.html.038739c8.js"><link rel="prefetch" href="/assets/flutter实用方法.html.553a1f3b.js"><link rel="prefetch" href="/assets/flutter常见问题.html.e51da1da.js"><link rel="prefetch" href="/assets/fvm.html.975adc70.js"><link rel="prefetch" href="/assets/Docker安装MySQL.html.b2d9d950.js"><link rel="prefetch" href="/assets/Docker安装Redis.html.23b77a64.js"><link rel="prefetch" href="/assets/docker安装nginx.html.1570f88c.js"><link rel="prefetch" href="/assets/docker常用命令.html.105d5b43.js"><link rel="prefetch" href="/assets/index.html.2c61ea97.js"><link rel="prefetch" href="/assets/package.json中版本号前面~和_的区别.html.ab36232a.js"><link rel="prefetch" href="/assets/使用Nexus搭建npm私服.html.c5e21e1d.js"><link rel="prefetch" href="/assets/前端基础设施建设.html.06019aa1.js"><link rel="prefetch" href="/assets/将npm包发布在私有仓库（nexus）中.html.b9601254.js"><link rel="prefetch" href="/assets/打造vue3组件库.html.8a668900.js"><link rel="prefetch" href="/assets/打造一款企业级cli脚手架.html.4d53b65b.js"><link rel="prefetch" href="/assets/git入门学习.html.e4bce7bb.js"><link rel="prefetch" href="/assets/git提交规范.html.acd9cbe6.js"><link rel="prefetch" href="/assets/如何把分支代码合并到master主分支上.html.003b1326.js"><link rel="prefetch" href="/assets/新版git提交到github.html.8b57c998.js"><link rel="prefetch" href="/assets/index.html.72b78845.js"><link rel="prefetch" href="/assets/Mac下使用 brew 安装mysql.html.89e22aff.js"><link rel="prefetch" href="/assets/mysql 基础操作.html.a0bbab91.js"><link rel="prefetch" href="/assets/inquirer报错Error.html.9873e08a.js"><link rel="prefetch" href="/assets/mddir项目结构生成包.html.15e5d0b2.js"><link rel="prefetch" href="/assets/npm指令集.html.abb34763.js"><link rel="prefetch" href="/assets/发布npm包到官方仓库.html.3737c2b3.js"><link rel="prefetch" href="/assets/pnpm基础.html.19bf3a4c.js"><link rel="prefetch" href="/assets/rollup打包问题.html.47d6191b.js"><link rel="prefetch" href="/assets/gin数据解析和解绑.html.253d7450.js"><link rel="prefetch" href="/assets/BFC.html.a7e3c004.js"><link rel="prefetch" href="/assets/CSS选择器及其优先级.html.0a35a7d6.js"><link rel="prefetch" href="/assets/index.html.91e251b0.js"><link rel="prefetch" href="/assets/eslint校验.html.1b110b83.js"><link rel="prefetch" href="/assets/jest.html.d66df8d5.js"><link rel="prefetch" href="/assets/link和@import的区别.html.1c0330f2.js"><link rel="prefetch" href="/assets/rollup.config.html.f4402541.js"><link rel="prefetch" href="/assets/tree-shaking原理.html.313b58c2.js"><link rel="prefetch" href="/assets/tsconfig.html.7aab1af4.js"><link rel="prefetch" href="/assets/uglify原理.html.a38ce5d0.js"><link rel="prefetch" href="/assets/utils.html.4cf1cc43.js"><link rel="prefetch" href="/assets/webpack loader机制.html.43257130.js"><link rel="prefetch" href="/assets/webpack工作流程.html.a16dbc10.js"><link rel="prefetch" href="/assets/webpack插件机制.html.ed47a88e.js"><link rel="prefetch" href="/assets/盒模型.html.9f485028.js"><link rel="prefetch" href="/assets/Flutter与原生通信的Channel有哪几种.html.6db14cbf.js"><link rel="prefetch" href="/assets/flutter基础面试题.html.80f40384.js"><link rel="prefetch" href="/assets/flutter生命周期.html.175185bd.js"><link rel="prefetch" href="/assets/简述Widget的StatelessWidget和StatefulWidget两种状态组件类.html.9a96bdeb.js"><link rel="prefetch" href="/assets/DOCTYPE 的作用，标准模式与怪异模式的区别.html.d1d63862.js"><link rel="prefetch" href="/assets/HTML5的离线储存，工作原理.html.ff22150f.js"><link rel="prefetch" href="/assets/行内元素与块级元素的区别.html.704c73a7.js"><link rel="prefetch" href="/assets/JavaScript原型_原型链_有什么特点.html.9abf527b.js"><link rel="prefetch" href="/assets/Javascript实现继承.html.ad781d8e.js"><link rel="prefetch" href="/assets/index.html.db00e42a.js"><link rel="prefetch" href="/assets/WebSocket.html.5f83b4c4.js"><link rel="prefetch" href="/assets/babel原理.html.de5275e1.js"><link rel="prefetch" href="/assets/bind、call、apply区别.html.1173a332.js"><link rel="prefetch" href="/assets/eslint校验.html.da0902da.js"><link rel="prefetch" href="/assets/eventLoop.html.0d4a14ad.js"><link rel="prefetch" href="/assets/jest.html.adcec9a2.js"><link rel="prefetch" href="/assets/js箭头函数和普通函数区别.html.412e40b6.js"><link rel="prefetch" href="/assets/new操作符.html.c0576f22.js"><link rel="prefetch" href="/assets/promise问题.html.e1ef4bdb.js"><link rel="prefetch" href="/assets/this指向问题.html.e23378f1.js"><link rel="prefetch" href="/assets/this的指向问题.html.d11f7077.js"><link rel="prefetch" href="/assets/tree-shaking原理.html.979ee8a6.js"><link rel="prefetch" href="/assets/typeof与instanceof区别.html.f590858f.js"><link rel="prefetch" href="/assets/uglify原理.html.f2019b98.js"><link rel="prefetch" href="/assets/var.html.89a0ee44.js"><link rel="prefetch" href="/assets/webpack loader机制.html.a0c85a8d.js"><link rel="prefetch" href="/assets/webpack工作流程.html.47ba8669.js"><link rel="prefetch" href="/assets/webpack插件机制.html.06c5e61b.js"><link rel="prefetch" href="/assets/关于原型的题目.html.5469e662.js"><link rel="prefetch" href="/assets/变量提升.html.a5fe76f6.js"><link rel="prefetch" href="/assets/常用的设计模式.html.3b7e62bc.js"><link rel="prefetch" href="/assets/强缓存与协商缓存.html.f8611978.js"><link rel="prefetch" href="/assets/微前端.html.ce014a6b.js"><link rel="prefetch" href="/assets/数组的常用方法.html.1061cf51.js"><link rel="prefetch" href="/assets/模块化机制.html.f7d66752.js"><link rel="prefetch" href="/assets/深拷贝浅拷贝的区别以及如何实现一个深拷贝.html.267a6887.js"><link rel="prefetch" href="/assets/说说你对闭包的理解以及闭包使用场景.html.7bb5bd06.js"><link rel="prefetch" href="/assets/说说对作用域链的理解.html.b5987088.js"><link rel="prefetch" href="/assets/防抖和节流.html.19c5db7e.js"><link rel="prefetch" href="/assets/cluster原理.html.cd1f7681.js"><link rel="prefetch" href="/assets/egg-bin.html.ec6edcf6.js"><link rel="prefetch" href="/assets/egg-cluster.html.538be63b.js"><link rel="prefetch" href="/assets/pipe原理.html.d8891333.js"><link rel="prefetch" href="/assets/require原理.html.50cd9f15.js"><link rel="prefetch" href="/assets/事件循环.html.7ef61431.js"><link rel="prefetch" href="/assets/异常处理.html.8ac2569b.js"><link rel="prefetch" href="/assets/模块机制.html.051dd273.js"><link rel="prefetch" href="/assets/流机制.html.340c83fc.js"><link rel="prefetch" href="/assets/进程守护.html.3c535ff4.js"><link rel="prefetch" href="/assets/进程通信.html.8f69cd41.js"><link rel="prefetch" href="/assets/MVC_MVVM_MVP.html.14bf2325.js"><link rel="prefetch" href="/assets/React16_17_18.html.1be189ae.js"><link rel="prefetch" href="/assets/Suspense.html.0fc05441.js"><link rel="prefetch" href="/assets/fiber.html.da323de7.js"><link rel="prefetch" href="/assets/hooks优缺点.html.5e1e9a3d.js"><link rel="prefetch" href="/assets/jsx原理.html.21afcc13.js"><link rel="prefetch" href="/assets/memo 和 useMemo.html.0db702ab.js"><link rel="prefetch" href="/assets/redux原理.html.3239e434.js"><link rel="prefetch" href="/assets/setState过程.html.584cee21.js"><link rel="prefetch" href="/assets/useLayoutEffect.html.5893332a.js"><link rel="prefetch" href="/assets/合成事件.html.555f93cf.js"><link rel="prefetch" href="/assets/常用设计模式.html.ba818b79.js"><link rel="prefetch" href="/assets/生命周期.html.9a0b8b01.js"><link rel="prefetch" href="/assets/组件间的通信方式.html.1421eee0.js"><link rel="prefetch" href="/assets/虚拟DOM.html.577443b5.js"><link rel="prefetch" href="/assets/错误处理.html.252b736e.js"><link rel="prefetch" href="/assets/高阶组件.html.f2749b28.js"><link rel="prefetch" href="/assets/vuex.html.281d7e6a.js"><link rel="prefetch" href="/assets/vue创建企业级项目.html.c05a00bd.js"><link rel="prefetch" href="/assets/vue实现双向数据绑定原理是什么.html.82f8abac.js"><link rel="prefetch" href="/assets/组建间的通信.html.0936df15.js"><link rel="prefetch" href="/assets/Tree-Shaking实现原理.html.63d13577.js"><link rel="prefetch" href="/assets/babel原理.html.c5757b92.js"><link rel="prefetch" href="/assets/eslint校验.html.d1a1d108.js"><link rel="prefetch" href="/assets/jest.html.6f678d76.js"><link rel="prefetch" href="/assets/rollup.config.html.05698c83.js"><link rel="prefetch" href="/assets/tree-shaking原理.html.fa41c39b.js"><link rel="prefetch" href="/assets/tsconfig.html.12eb5399.js"><link rel="prefetch" href="/assets/uglify原理.html.6acf0198.js"><link rel="prefetch" href="/assets/utils.html.72cfd0be.js"><link rel="prefetch" href="/assets/webpack loader机制.html.eaf35051.js"><link rel="prefetch" href="/assets/webpack工作流程.html.f80ce981.js"><link rel="prefetch" href="/assets/webpack插件机制.html.0fa493cf.js"><link rel="prefetch" href="/assets/微前端.html.f3027cd7.js"><link rel="prefetch" href="/assets/模块化机制.html.eef5a072.js"><link rel="prefetch" href="/assets/常见的shell脚本.html.4f8d31d6.js"><link rel="prefetch" href="/assets/webp.html.6761fab5.js"><link rel="prefetch" href="/assets/从浏览器输入到页面展示的过程.html.522552a8.js"><link rel="prefetch" href="/assets/内存泄漏.html.af8e0ecf.js"><link rel="prefetch" href="/assets/前端性能优化手段.html.266261fe.js"><link rel="prefetch" href="/assets/动画性能.html.a2b6e745.js"><link rel="prefetch" href="/assets/大量图片加载优化.html.f1d8c803.js"><link rel="prefetch" href="/assets/性能指标.html.8ccb6f02.js"><link rel="prefetch" href="/assets/性能计算.html.0581ff75.js"><link rel="prefetch" href="/assets/渲染合成层.html.daf7eeea.js"><link rel="prefetch" href="/assets/白屏.html.20146db6.js"><link rel="prefetch" href="/assets/重排和重绘.html.3900a27d.js"><link rel="prefetch" href="/assets/cicd.html.ba6874f8.js"><link rel="prefetch" href="/assets/css.html.ab2ae764.js"><link rel="prefetch" href="/assets/es6新特性.html.29bf0cd1.js"><link rel="prefetch" href="/assets/eventloop.html.403b64f8.js"><link rel="prefetch" href="/assets/hooks 和vue响应式对比.html.47d558ae.js"><link rel="prefetch" href="/assets/hooks生命周期.html.5cf940e9.js"><link rel="prefetch" href="/assets/ts相关问题.html.ea638906.js"><link rel="prefetch" href="/assets/weebpack.html.fa621f21.js"><link rel="prefetch" href="/assets/从url输入到页面显示会有哪些步骤.html.795e82d4.js"><link rel="prefetch" href="/assets/前端安全.html.c5020f76.js"><link rel="prefetch" href="/assets/基础题.html.06cccde8.js"><link rel="prefetch" href="/assets/对象相关问题.html.d2dd2cbe.js"><link rel="prefetch" href="/assets/数组.html.b7fdd806.js"><link rel="prefetch" href="/assets/普通函数和箭头函数的区别.html.55d02210.js"><link rel="prefetch" href="/assets/汽车之家.html.107be28a.js"><link rel="prefetch" href="/assets/移动端问题.html.f366f28e.js"><link rel="prefetch" href="/assets/纯函数.html.d8bf03e3.js"><link rel="prefetch" href="/assets/缓存.html.0929dfe4.js"><link rel="prefetch" href="/assets/网络.html.2ee2d2ed.js"><link rel="prefetch" href="/assets/考试记录.html.469eca04.js"><link rel="prefetch" href="/assets/记录.html.a12b0684.js"><link rel="prefetch" href="/assets/跨域.html.0dad1915.js"><link rel="prefetch" href="/assets/重绘和重排.html.0b35012b.js"><link rel="prefetch" href="/assets/冒泡排序.html.e8a92747.js"><link rel="prefetch" href="/assets/反转ul.html.74aa08c6.js"><link rel="prefetch" href="/assets/查找对象路径.html.00d118b6.js"><link rel="prefetch" href="/assets/统计数组中值的出现次数.html.638fe9c7.js"><link rel="prefetch" href="/assets/JavaScript经典手写题.html.de19711d.js"><link rel="prefetch" href="/assets/函数柯里化.html.2f6b21bd.js"><link rel="prefetch" href="/assets/函数缓存.html.d64f8ae7.js"><link rel="prefetch" href="/assets/反转链表.html.37c6b483.js"><link rel="prefetch" href="/assets/实现原生的AJAX请求.html.d67e5996.js"><link rel="prefetch" href="/assets/手写防抖和节流.html.675a264c.js"><link rel="prefetch" href="/assets/整数反转.html.de49aa62.js"><link rel="prefetch" href="/assets/TCP三次握手和四次挥手.html.8d82ce35.js"><link rel="prefetch" href="/assets/全排列.html.8ba52830.js"><link rel="prefetch" href="/assets/404.html.265028f6.js"><link rel="prefetch" href="/assets/index.html.6f53ee0d.js"><link rel="prefetch" href="/assets/MAC上安装brew方式及使用技巧.html.ef700de8.js"><link rel="prefetch" href="/assets/Mac下修改hosts 解决访问github慢的问题.html.68882914.js"><link rel="prefetch" href="/assets/mac下docker安装kenkins.html.0e9e45b2.js"><link rel="prefetch" href="/assets/视频流.html.77fdc283.js"><link rel="prefetch" href="/assets/egg中间件.html.ee842042.js"><link rel="prefetch" href="/assets/egg基础.html.d519f9a1.js"><link rel="prefetch" href="/assets/egg定时任务.html.a56a5146.js"><link rel="prefetch" href="/assets/index.html.535fab4b.js"><link rel="prefetch" href="/assets/生成接口文档egg-swagger-doc.html.08d38e86.js"><link rel="prefetch" href="/assets/Ubuntu下安装AndroidStudio.html.91398eb2.js"><link rel="prefetch" href="/assets/安卓打包icon及其启动页图片大小.html.067f99c5.js"><link rel="prefetch" href="/assets/Flutter-原生路由.html.b3920056.js"><link rel="prefetch" href="/assets/Flutter-常用库及时使用入门级方法-一些经常用到的的副本.html.bcb3d256.js"><link rel="prefetch" href="/assets/Flutter创建插件详解并发布到Pub库.html.3963b37b.js"><link rel="prefetch" href="/assets/flutter_fluro.html.6215122c.js"><link rel="prefetch" href="/assets/flutter_mqtt.html.e2f0a895.js"><link rel="prefetch" href="/assets/flutter实用方法.html.175c12e2.js"><link rel="prefetch" href="/assets/flutter常见问题.html.dda33e65.js"><link rel="prefetch" href="/assets/fvm.html.9b86b558.js"><link rel="prefetch" href="/assets/Docker安装MySQL.html.66fa2143.js"><link rel="prefetch" href="/assets/Docker安装Redis.html.d04f8a09.js"><link rel="prefetch" href="/assets/docker安装nginx.html.2378d648.js"><link rel="prefetch" href="/assets/docker常用命令.html.bc060ba4.js"><link rel="prefetch" href="/assets/index.html.4bad2743.js"><link rel="prefetch" href="/assets/package.json中版本号前面~和_的区别.html.7445a86c.js"><link rel="prefetch" href="/assets/使用Nexus搭建npm私服.html.c7891b5d.js"><link rel="prefetch" href="/assets/前端基础设施建设.html.03a962d3.js"><link rel="prefetch" href="/assets/将npm包发布在私有仓库（nexus）中.html.fd34a088.js"><link rel="prefetch" href="/assets/打造vue3组件库.html.271f2ab7.js"><link rel="prefetch" href="/assets/打造一款企业级cli脚手架.html.91a4ebf6.js"><link rel="prefetch" href="/assets/git入门学习.html.7bc625a1.js"><link rel="prefetch" href="/assets/git提交规范.html.0a19a3a1.js"><link rel="prefetch" href="/assets/如何把分支代码合并到master主分支上.html.d13ebd88.js"><link rel="prefetch" href="/assets/新版git提交到github.html.e772d176.js"><link rel="prefetch" href="/assets/index.html.58d77fa1.js"><link rel="prefetch" href="/assets/Mac下使用 brew 安装mysql.html.3689c984.js"><link rel="prefetch" href="/assets/mysql 基础操作.html.61bb03db.js"><link rel="prefetch" href="/assets/inquirer报错Error.html.98e3336b.js"><link rel="prefetch" href="/assets/mddir项目结构生成包.html.809ef953.js"><link rel="prefetch" href="/assets/npm指令集.html.d83631d7.js"><link rel="prefetch" href="/assets/发布npm包到官方仓库.html.b60261aa.js"><link rel="prefetch" href="/assets/pnpm基础.html.d3349cca.js"><link rel="prefetch" href="/assets/rollup打包问题.html.2c54e95d.js"><link rel="prefetch" href="/assets/gin数据解析和解绑.html.c2c1243e.js"><link rel="prefetch" href="/assets/BFC.html.d25c85b6.js"><link rel="prefetch" href="/assets/CSS选择器及其优先级.html.e527aeaa.js"><link rel="prefetch" href="/assets/index.html.59c239cc.js"><link rel="prefetch" href="/assets/eslint校验.html.cd1047d0.js"><link rel="prefetch" href="/assets/jest.html.11787af9.js"><link rel="prefetch" href="/assets/link和@import的区别.html.6528ea6a.js"><link rel="prefetch" href="/assets/rollup.config.html.4db0a59a.js"><link rel="prefetch" href="/assets/tree-shaking原理.html.099395ff.js"><link rel="prefetch" href="/assets/tsconfig.html.dcdd7f5f.js"><link rel="prefetch" href="/assets/uglify原理.html.b1d3ba3d.js"><link rel="prefetch" href="/assets/utils.html.06c18974.js"><link rel="prefetch" href="/assets/webpack loader机制.html.80933cf6.js"><link rel="prefetch" href="/assets/webpack工作流程.html.6e105335.js"><link rel="prefetch" href="/assets/webpack插件机制.html.4eddaec2.js"><link rel="prefetch" href="/assets/盒模型.html.fae3ebcd.js"><link rel="prefetch" href="/assets/Flutter与原生通信的Channel有哪几种.html.06887c47.js"><link rel="prefetch" href="/assets/flutter基础面试题.html.08b0803a.js"><link rel="prefetch" href="/assets/flutter生命周期.html.2f3dfd3d.js"><link rel="prefetch" href="/assets/简述Widget的StatelessWidget和StatefulWidget两种状态组件类.html.bab6c76c.js"><link rel="prefetch" href="/assets/DOCTYPE 的作用，标准模式与怪异模式的区别.html.f849864d.js"><link rel="prefetch" href="/assets/HTML5的离线储存，工作原理.html.41bb171c.js"><link rel="prefetch" href="/assets/行内元素与块级元素的区别.html.9a524a86.js"><link rel="prefetch" href="/assets/JavaScript原型_原型链_有什么特点.html.66726a26.js"><link rel="prefetch" href="/assets/Javascript实现继承.html.ae56dfdb.js"><link rel="prefetch" href="/assets/index.html.01657ba8.js"><link rel="prefetch" href="/assets/WebSocket.html.5ad70f2c.js"><link rel="prefetch" href="/assets/babel原理.html.1de09b42.js"><link rel="prefetch" href="/assets/bind、call、apply区别.html.be78e8fc.js"><link rel="prefetch" href="/assets/eslint校验.html.7dd26a0a.js"><link rel="prefetch" href="/assets/eventLoop.html.6ed0ebff.js"><link rel="prefetch" href="/assets/jest.html.5c8ebc12.js"><link rel="prefetch" href="/assets/js箭头函数和普通函数区别.html.f1d76244.js"><link rel="prefetch" href="/assets/new操作符.html.a0902fc1.js"><link rel="prefetch" href="/assets/promise问题.html.81e2f8f3.js"><link rel="prefetch" href="/assets/this指向问题.html.a360d2ae.js"><link rel="prefetch" href="/assets/this的指向问题.html.652ddc09.js"><link rel="prefetch" href="/assets/tree-shaking原理.html.a9767112.js"><link rel="prefetch" href="/assets/typeof与instanceof区别.html.8d4687cb.js"><link rel="prefetch" href="/assets/uglify原理.html.14afcc55.js"><link rel="prefetch" href="/assets/var.html.b50cac53.js"><link rel="prefetch" href="/assets/webpack loader机制.html.1218611a.js"><link rel="prefetch" href="/assets/webpack工作流程.html.f3f9a21e.js"><link rel="prefetch" href="/assets/webpack插件机制.html.c2c0171c.js"><link rel="prefetch" href="/assets/关于原型的题目.html.342b573f.js"><link rel="prefetch" href="/assets/变量提升.html.2c7a0c3f.js"><link rel="prefetch" href="/assets/常用的设计模式.html.1cbf2b5a.js"><link rel="prefetch" href="/assets/强缓存与协商缓存.html.7f665733.js"><link rel="prefetch" href="/assets/微前端.html.c78ad5bb.js"><link rel="prefetch" href="/assets/数组的常用方法.html.d127b7d1.js"><link rel="prefetch" href="/assets/模块化机制.html.a37d0af9.js"><link rel="prefetch" href="/assets/深拷贝浅拷贝的区别以及如何实现一个深拷贝.html.1dd3b67b.js"><link rel="prefetch" href="/assets/说说你对闭包的理解以及闭包使用场景.html.011f5052.js"><link rel="prefetch" href="/assets/说说对作用域链的理解.html.413ff483.js"><link rel="prefetch" href="/assets/防抖和节流.html.229cff05.js"><link rel="prefetch" href="/assets/cluster原理.html.14b8b61b.js"><link rel="prefetch" href="/assets/egg-bin.html.085e1d4b.js"><link rel="prefetch" href="/assets/egg-cluster.html.99c8e858.js"><link rel="prefetch" href="/assets/pipe原理.html.81393670.js"><link rel="prefetch" href="/assets/require原理.html.d43e113d.js"><link rel="prefetch" href="/assets/事件循环.html.3cf701fb.js"><link rel="prefetch" href="/assets/异常处理.html.25138c12.js"><link rel="prefetch" href="/assets/模块机制.html.c79b3240.js"><link rel="prefetch" href="/assets/流机制.html.c3131ead.js"><link rel="prefetch" href="/assets/进程守护.html.316a5815.js"><link rel="prefetch" href="/assets/进程通信.html.2c2f6d9f.js"><link rel="prefetch" href="/assets/MVC_MVVM_MVP.html.0ffc5c72.js"><link rel="prefetch" href="/assets/React16_17_18.html.344d12f9.js"><link rel="prefetch" href="/assets/Suspense.html.ac2b0587.js"><link rel="prefetch" href="/assets/fiber.html.3bc04540.js"><link rel="prefetch" href="/assets/hooks优缺点.html.ad700e07.js"><link rel="prefetch" href="/assets/jsx原理.html.d3f3576f.js"><link rel="prefetch" href="/assets/memo 和 useMemo.html.c2127b5a.js"><link rel="prefetch" href="/assets/redux原理.html.49095703.js"><link rel="prefetch" href="/assets/setState过程.html.d3c86fde.js"><link rel="prefetch" href="/assets/useLayoutEffect.html.4579c38f.js"><link rel="prefetch" href="/assets/合成事件.html.7f633ded.js"><link rel="prefetch" href="/assets/常用设计模式.html.1eaad073.js"><link rel="prefetch" href="/assets/生命周期.html.2b325ea0.js"><link rel="prefetch" href="/assets/组件间的通信方式.html.130905cd.js"><link rel="prefetch" href="/assets/虚拟DOM.html.9a74bead.js"><link rel="prefetch" href="/assets/错误处理.html.8809e25c.js"><link rel="prefetch" href="/assets/高阶组件.html.4bae8cfc.js"><link rel="prefetch" href="/assets/vuex.html.d83d4eb7.js"><link rel="prefetch" href="/assets/vue创建企业级项目.html.39177e29.js"><link rel="prefetch" href="/assets/vue实现双向数据绑定原理是什么.html.cef2cac6.js"><link rel="prefetch" href="/assets/组建间的通信.html.adabe582.js"><link rel="prefetch" href="/assets/Tree-Shaking实现原理.html.19d303a0.js"><link rel="prefetch" href="/assets/babel原理.html.aab9e94d.js"><link rel="prefetch" href="/assets/eslint校验.html.9c74d298.js"><link rel="prefetch" href="/assets/jest.html.6a698d2b.js"><link rel="prefetch" href="/assets/rollup.config.html.c2a21cf8.js"><link rel="prefetch" href="/assets/tree-shaking原理.html.d31e7496.js"><link rel="prefetch" href="/assets/tsconfig.html.2cb335e2.js"><link rel="prefetch" href="/assets/uglify原理.html.e936a555.js"><link rel="prefetch" href="/assets/utils.html.caead205.js"><link rel="prefetch" href="/assets/webpack loader机制.html.cd7a4c4e.js"><link rel="prefetch" href="/assets/webpack工作流程.html.6aa5e53c.js"><link rel="prefetch" href="/assets/webpack插件机制.html.f59f3a6c.js"><link rel="prefetch" href="/assets/微前端.html.8686093f.js"><link rel="prefetch" href="/assets/模块化机制.html.ac690e0c.js"><link rel="prefetch" href="/assets/常见的shell脚本.html.1571a466.js"><link rel="prefetch" href="/assets/webp.html.feb6ac9c.js"><link rel="prefetch" href="/assets/从浏览器输入到页面展示的过程.html.3347efc9.js"><link rel="prefetch" href="/assets/内存泄漏.html.bfef1ded.js"><link rel="prefetch" href="/assets/前端性能优化手段.html.76f7d997.js"><link rel="prefetch" href="/assets/动画性能.html.2e3a3508.js"><link rel="prefetch" href="/assets/大量图片加载优化.html.bd3047b0.js"><link rel="prefetch" href="/assets/性能指标.html.ddc0976a.js"><link rel="prefetch" href="/assets/性能计算.html.4aa8438d.js"><link rel="prefetch" href="/assets/渲染合成层.html.11bc00a5.js"><link rel="prefetch" href="/assets/白屏.html.267992b5.js"><link rel="prefetch" href="/assets/重排和重绘.html.3b29b473.js"><link rel="prefetch" href="/assets/cicd.html.894fad2d.js"><link rel="prefetch" href="/assets/css.html.3b6c32f3.js"><link rel="prefetch" href="/assets/es6新特性.html.a69b62fe.js"><link rel="prefetch" href="/assets/eventloop.html.7813df50.js"><link rel="prefetch" href="/assets/hooks 和vue响应式对比.html.fe6bccb8.js"><link rel="prefetch" href="/assets/hooks生命周期.html.6fb6d6aa.js"><link rel="prefetch" href="/assets/ts相关问题.html.630f00ec.js"><link rel="prefetch" href="/assets/weebpack.html.5b9138f7.js"><link rel="prefetch" href="/assets/从url输入到页面显示会有哪些步骤.html.01813723.js"><link rel="prefetch" href="/assets/前端安全.html.8d8a93f9.js"><link rel="prefetch" href="/assets/基础题.html.cbf4b76f.js"><link rel="prefetch" href="/assets/对象相关问题.html.07a98f1c.js"><link rel="prefetch" href="/assets/数组.html.52b158ba.js"><link rel="prefetch" href="/assets/普通函数和箭头函数的区别.html.0ef80be0.js"><link rel="prefetch" href="/assets/汽车之家.html.cf6d4a70.js"><link rel="prefetch" href="/assets/移动端问题.html.0fe2e90f.js"><link rel="prefetch" href="/assets/纯函数.html.230704e1.js"><link rel="prefetch" href="/assets/缓存.html.2217bab2.js"><link rel="prefetch" href="/assets/网络.html.c410583c.js"><link rel="prefetch" href="/assets/考试记录.html.49322397.js"><link rel="prefetch" href="/assets/记录.html.02fd6fcc.js"><link rel="prefetch" href="/assets/跨域.html.d1e9e8aa.js"><link rel="prefetch" href="/assets/重绘和重排.html.d96704cc.js"><link rel="prefetch" href="/assets/冒泡排序.html.a4a0fb93.js"><link rel="prefetch" href="/assets/反转ul.html.c10bb138.js"><link rel="prefetch" href="/assets/查找对象路径.html.8486d7ec.js"><link rel="prefetch" href="/assets/统计数组中值的出现次数.html.e2889d97.js"><link rel="prefetch" href="/assets/JavaScript经典手写题.html.4204ee90.js"><link rel="prefetch" href="/assets/函数柯里化.html.d3200afa.js"><link rel="prefetch" href="/assets/函数缓存.html.0ccc5b14.js"><link rel="prefetch" href="/assets/反转链表.html.99432f1b.js"><link rel="prefetch" href="/assets/实现原生的AJAX请求.html.a101777b.js"><link rel="prefetch" href="/assets/手写防抖和节流.html.7a5cae72.js"><link rel="prefetch" href="/assets/整数反转.html.1093b6c0.js"><link rel="prefetch" href="/assets/TCP三次握手和四次挥手.html.439438d9.js"><link rel="prefetch" href="/assets/全排列.html.73896b05.js"><link rel="prefetch" href="/assets/404.html.1c1d6c36.js"><link rel="prefetch" href="/assets/404.b82f652a.js"><link rel="prefetch" href="/assets/Layout.af4a0b33.js">
    <link rel="stylesheet" href="/assets/style.f4d22aab.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="切换侧边栏" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><!----><span class="site-name">小郑的博客</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/guide/" class="" aria-label="指南"><!--[--><!--]--> 指南 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="面试"><span class="title">面试</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="面试"><span class="title">面试</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/interview/css/" class="" aria-label="css"><!--[--><!--]--> css <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/interview/javascript/" class="" aria-label="javascript"><!--[--><!--]--> javascript <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a href="/frontend/" class="" aria-label="前端"><!--[--><!--]--> 前端 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="切换颜色模式"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/guide/" class="" aria-label="指南"><!--[--><!--]--> 指南 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="面试"><span class="title">面试</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="面试"><span class="title">面试</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/interview/css/" class="" aria-label="css"><!--[--><!--]--> css <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/interview/javascript/" class="" aria-label="javascript"><!--[--><!--]--> javascript <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a href="/frontend/" class="" aria-label="前端"><!--[--><!--]--> 前端 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><a aria-current="page" href="/interview/" class="router-link-active router-link-exact-active router-link-active sidebar-item sidebar-heading active" aria-label><!--[--><!--]-->  <!--[--><!--]--></a><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><p>一： Vue router: https://juejin.cn/post/6844904169954869262 前端路由 随着前端单页应用(SPA)的兴起，前端页面完全变成了组件化，不同的页面就是不同的组件，页面的切换就是组件的切换；页面切换的时候不需要再通过http请求，直接通过JS解析url地址，然后找到对应的组件进行渲染</p><p>前端路由的优点就是组件切换不需要发送http请求，切换跳转快，用户体验好；缺点就是没有合理的利用缓存且不利于SEO</p><p>分为 hash 和 history 两种模式，这两种方式都不会向服务器发起新的请求，hash通过监听hashChange事件改变路由， history 方式通过监听 popState 事件来改变路由。router 获取的方式：hash 通过location.hash， history 通过 location.pathname history模式是另一种前端路由模式，它基于HTML5的history对象 通过location.pathname获取到当前url的路由地址；history模式下，通过pushState和replaceState方法可以修改url地址，结合popstate方法监听url中路由的变化</p><p>Vue Routrer核心是：通过Vue.use 注册插件获取router的配置。当url 改变时，router 获取路由和对应的组件，保存一个当前的路由对象current，当浏览器地址改变的时候修改对象current。当current 改变时获取相应的component进行视图渲染 vue-router工作流程</p><ol><li>创建一个current 对象记录当前url</li><li>监听hashChange 或者popState 事件，通过pushState和replaceState方法可以修改url地址，改变current</li><li>监视current变量的监视者</li><li>在路由列表中查找路由对应的组件</li><li>render 渲染到页面上 Vue.use()方法用于插件安装，通过它可以将一些功能或API入侵到Vue内部； install方法接收一个Vue实例作为参数，通过Vue.mixin()全局混入beforeCreated生命周期钩子；通过Vue实例暴露的工具方法defineReactive将current属性变成一个监视者</li></ol><p>二： VUE2 和VUE3 的区别 vue2 无法监听数组的变化，因为性能收益 问题没有对数组每个元素加上监听https://blog.csdn.net/JackieDYH/article/details/114253038 1.object.defineProperty 和 proxy 的区别 proxy： 代理：拦截对象，可以访问整个对象的所有属性，省去了对对象所有属性的遍历，和对嵌套对象的深度遍历 object.defineProperty： 必须遍历对象的每个属性结合object.keys().forEach</p><p>2.vue3 框架改用ts 语言，所以可以更好的支持了ts</p><p>3.vue3 支持响应式API，函数式编程，例如react 的hooks 。抛弃生命周期可以将逻辑抽离成更小的函数，方便复用。</p><p>4.虚拟dom与静态标记/事件缓存：vue 模版的优化，递归便利每一个节点标记是否是静态节点，静态节点不会加入diff算法的比较， 5.传入的事件会自动生成并缓存一个内联函数再cache里，变为一个静态节点。这样就算我们自己写内联函数，也不会导致多余的重复渲染。</p><p>二： VUEX 原理： state， getters， muttations， actions， moudule 辅助函数： mapState，mapGetters， MapActions，MapMutations</p><p>1.使用Vuex只需执行 Vue.use(Vuex)，并在Vue的配置中传入一个store对象的示例，store是如何实现注入的？ 1.利用vue.use 方法进行vuex 的安装，然后利用全局mixin方法在vue 的beforeCreated 生命周期的钩子上将传入的store 对象设置到vue 上下文环境的$store中。因此在Vue Component任意地方都能够通过this.$store访问到该store。</p><p>2.vuex的state和getters是如何映射到各个组件实例中响应式更新状态呢？ vuex 的state 是响应式的，是借助vue的data实现的响应式，将state存入vue 实例组件的data 中，vuex的getters是借助vue的computed实现实时监听的</p><p>3.state内部支持模块配置和模块嵌套，如何实现的？ 在store构造方法中有makeLocalContext方法，所有module都会有一个local context，根据配置时的path进行匹配。所以执行如dispatch(&#39;submitOrder&#39;, payload)这类action时，默认的拿到都是module的local state，如果要访问最外层或者是其他module的state，只能从rootState按照path路径逐步进行访问。</p><p>四： Vue 中 key 的作用是：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速</p><p>五：vue 文件如何渲染和一个html 页面的</p><p>六： 组件间的通信方式（vue&amp; react） react：props，ref， 回调函数，context，redux vue：props， ref，$emit, eventBus，用多了容易混乱 （parent, children 不推荐）</p><p>七： nextTick nextTick() 是将回调函数延迟在下一次dom更新数据后调用，简单理解是数据更新了，dom 中渲染后，自动执行该函数。 nextTick 的作用：created 勾子执行的时候dom 并未渲染，mounted 勾子所有dom 已经渲染完成，所以想要在created 上操作dom 就需要使用nextTick（）</p><p>Vue.nextTick(callback) 使用原理： 原因是，Vue 是异步执行 dom 更新的，一旦观察到数据变化，Vue 就会开启一个队列，然后把在同一个事件循环 (event loop) 当中观察到数据变化的 watcher 推送进这个队列。如果这个 watcher 被触发多次，只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和 DOm 操作。而在下一个事件循环时，Vue 会清空队列，并进行必要的 DOM 更新。 当你设置 vm.someData = ‘new value’，DOM 并不会马上更新，而是在异步队列被清除，也就是下一个事件循环开始时执行更新时才会进行必要的 DOM 更新。如果此时你想要根据更新的 DOM 状态去做某些事情，就会出现问题。。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。</p><p>30 道vue 面试题：https://juejin.cn/post/6844903918753808398 https://mp.weixin.qq.com/s/NkUZCBkX-NoF6yVDkavcsA</p><p>Keep- Alive： keep-alive是Vue.js的一个内置组件。它能够不活动的组件实例保存在内存中，而不是直接将其销毁，它是一个抽象组件，不会被渲染到真实DOM中，也不会出现在父组件链中。它提供了include与exclude两个属性，允许组件有条件地进行缓存。 keep-alive提供了两个生命钩子，分别是activated与deactivated。 因为keep-alive会将组件保存在内存中，并不会销毁以及重新创建，所以不会重新调用组件的created等方法，需要用activated与deactivated这两个生命钩子来得知当前组件是否处于活动状态。 原理：在 created 函数调用时将需要缓存的 VNode 节点保存在 this.cache 中；在 render（页面渲染） 时，如果 VNode 的 name 符合缓存条件（可以用 include 以及 exclude 控制），则会从 this.cache 中取出之前缓存的 VNode 实例进行渲染。</p><p>响应式数据原理 默认 Vue 在初始化数据时，会给 data 中的属性使用 Object.defineProperty 重新定义所有属性，当页面到对应属性时，会进行依赖收集(收集当前组件中的 watcher)如果属性发生变化会通知相关依赖进行更新操作在响应式属性发生更新时通知 Watcher 去重新调用 vm._update(vm._render()) 进行组件的视图更新</p><p>vue 采用异步渲染：因为如果不采用异步更新，那么每次更新数据都会对当前租金按进行重新渲染，所以为了性能考虑，Vue 会在本轮数据更新后，再去异步更新数据</p><p>Vue Mixin 的缺点：依赖不明确，命名如果冲突本地覆盖mixin。vue3 composition API更好</p><p>vue能监听到数组变化的方法有哪些？为什么这些方法能监听到呢？ 无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应 push() pop() shift() unshift() splice() sort() reverse() 原理就是重写数组的七个原始方法,当使用者执行这些方法时,我们就可以监听到数据的变化,然后再使用原形上的方法然后做些跟新操作,下面我们在observer中加上关于对数组的判断</p><p>VUE 数据的双向绑定原理：Vue实现数据双向绑定主要利用的就是: 数据劫持和发布订阅模式。 所谓发布订阅模式就是，定义了对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。</p><p>所谓数据劫持，就是利用JavaScript的访问器属性，即Object.defineProperty()方法或者proxy 方法，当对对象的属性进行赋值时，Object.defineProperty就可以通过set方法劫持到数据的变化，然后通知发布者(主题对象)去通知所有观察者，观察者收到通知后，就会对视图进行更新。</p><p>在创建Vue实例的过程中，会对Vue data中的数据进行数据劫持操作，即将data上的属性都通过Object.definePropery()的方式代理到Vue实例上，当View视图或者Vue Model中发生数据变化的时候，就会被劫持，然后通知Dep发布者对象进行视图的更新，从而实现数据的双向绑定。</p><p>Vue3.0中Ref与Reactive的区别是什么</p><p>上面我们提到 reactive 只能给对象，数组 添加响应式，如果想给值类型(String，Number，Boolean，Symbol)添加响应式，就要用到ref，所以ref作用如下：</p><p>首先我们都知道ref函数和reactive函数都是用来定义响应式数据； 但是reactive更适合定义复杂的数据类型（json/arr）、ref适合定义基本数据类型（可接收基本数据类型和对象）</p><p>Ref在模板调用可以直接省略value，在方法中改变变量的值需要修改value的值，才能修改成功。Reactive在模板必须写全不然显示整个数据。</p><p>Reactive的本质是将每一层的数都解析成proxy对象，Reactive 的响应式默认都是递归的，改变某一层的值都会递归的调用一遍，重新渲染dom。 参数必须是对象或者数组，如果要让对象的某个元素实现响应式时比较麻烦。需要使用toRefs</p><p>ref: (1)函数参数可以是基本数据类型，也可以接受对象类型</p><p>(2)如果参数是对象类型时，其实底层的本质还是reactive,系统会自动根据我们给ref传入的值转换成： ref(1)-&gt;reactive({value:1})</p><p>ref函数只能操作浅层次的数据，把基本数据类型当作自己的属性值；深层次依赖于reactive</p><p>ref响应式原理是依赖于Object.defineProperty()的get()和set()的。</p><p>toRef 针对一个响应式对象（reactive 封装）的 prop（属性）创建一个ref，且保持响应式 两者 保持引用关系</p><p>setup () { // 响应式对象 const state = reactive({ name: &#39;太凉&#39;, age: 18 })</p><pre><code>// 通过toRef创建一个Ref响应式
const nameRef = toRef(state, &#39;name&#39;)
</code></pre><p>}</p><p>toRefs toRefs 是一种用于破坏响应式对象并将其所有属性转换为 ref 的实用方法</p><p>将响应式对象（reactive封装）转成普通对象 对象的每个属性(Prop)都是对应的ref 两者保持引用关系</p></div><!--[--><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">上次更新: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">贡献者: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: zhengzhuang@zhengzhngdeMBP2.www.idazoo.com">郑壮</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app.73a0ea12.js" defer></script>
  </body>
</html>
